# -*- coding: utf-8 -*-
"""ED.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16X3ogljtRQQYr4nJD1AOoOdG1zDy5eK1

# **PRACTICE for Quantum Quenching**

**just making the hamiltonian**
"""

import math
import sys
import numpy as np
import scipy.sparse
import scipy.sparse.linalg
import scipy as scipy
import scipy.integrate as integrate
import argparse
import time
import copy
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
#to work on the arguments passed on

def parse_args():
    parser = argparse.ArgumentParser(description='Dynamics of S=1/2 TFI chain')
    parser.add_argument('-N',metavar='N',dest='N',type=int,default=10,help='set Nsize (should be >=4)')
    return parser.parse_args()
def make_spin():
  S0=scipy.sparse.csr_matrix(np.array([[1.0,0.0],[0.0,1.0]],dtype=float))
  Sx=scipy.sparse.csr_matrix(np.array([[0.0,1.0],[1.0,0.0]],dtype=float))
  Sy=scipy.sparse.csr_matrix(np.array([[0.0,-1.0j],[1.0j,0.0]],dtype=complex))
  Sz=scipy.sparse.csr_matrix(np.array([[1.0,0.0],[0.0,-1.0]],dtype=float))
  return S0,Sx,Sy,Sz
def make_list_2(N):                #two site block Jzz
  list_site1=[i for i in range(N)]
  list_site2=[(i+1)%N for i in range(N)]
  list_Jzz= np.ones(N , dtype=float)
  return list_site1,list_site2,list_Jzz
def make_list_1(N):              #for left over
  list_Jz = np.ones(N , dtype=float)
  return list_Jz

def make_list_1_stag(N):
  list_Jz = np.array([1.0 if i%2 == 0 else -1.0 for i in range(N)],dtype=float)
  return list_Jz

def make_hamiltonian_2(S0,Sz,N,Nbond,list_site1,list_site2,list_Jzz): #taking care of the mutual term applied at each block
  Hamil_new = scipy.sparse.csr_matrix((2**N,2**N),dtype=float)
  for bond in range(Nbond):
    i1=list_site1[bond]
    i2=list_site2[bond]
    Jzz=list_Jzz[bond]
    SzSz = 1
    for site in range(N):
      if site==i1 or site==i2:
        SzSz=scipy.sparse.kron(SzSz,Sz,format='csr')
      else:
        SzSz=scipy.sparse.kron(SzSz,S0,format='csr')
    Hamil_new=-(Hamil_new+Jzz*SzSz)
  return Hamil_new
def make_hamiltonian_1(S0, Sz, N, list_Jz):
  Hmail_new_1 = scipy.sparse.csr_matrix((2**N, 2**N), dtype=float)
  for site1 in range(N):
    ISz = 1
    Jz = list_Jz[site1]  # Accessing the element from list_Jz
    for site2 in range(N):
      if site1 == site2:
        ISz = scipy.sparse.kron(ISz, Sz, format='csr')
      else:
        ISz = scipy.sparse.kron(ISz, S0, format='csr')
    Hmail_new_1 -= Jz * ISz  # Multiplying by the scalar Jz
  return Hmail_new_1
############################## BEGINNING ANALYSIS #########################################

"""# **(magnetization,loschmidt_values(analytical formula got from the internet),density imabalnce)**"""

def epsion(J,h,k):
  return 2.0*np.sqrt(1.0+h**2-2.0*h*np.cos(k))
def diff_loschmidt_echo(J,h0,h1,k,t):
  e0 = epsion(J,h0,k)
  e1 = epsion(J,h1,k)
  denom = e0*e1
  numer = 4.0*J**2 * (h1-h0) * np.sin(k) * np.sin(e1*t)
  return np.log(1.0 - (numer/denom)**2)/(-2.0*np.pi)
def diff_loschmidt_echo_main(k,c):
  return diff_loschmidt_echo_main(c[0],c[1],c[2],k,c[3])
def integrating_loschmidt_echo(J,h0,h1,tau,dt):
  list_vt = []
  list_loschmidt_echo = []
  vmax = 2.0*j*np.min(1.0,h1)
  tmax = tau/vmax
  N = int(tmax/dt+0.1)+1
  for steps in range(N):
      t = steps*dt
      log_loschmidt_echo = integrate.quad(lambda k,c : \
          diff_loschmidt_echo_main(k,c), 0.0, np.pi, args=[J,h0,h1,t])
      list_vt.append(vmax*t)
      list_loschmidt_echo.append(log_loschmidt_echo[0])
  return list_vt, list_loschmidt_echo
def main():
  # np.set_print_options(threshold=1000)
  args=parse_args()
  N=args.N
  Nbond=N

  field_i = 1e10
  field_f = 0.1
  print("N = ",N)
  print("field_i = ", field_i)
  print("field_f = ", field_f)
  print("Nbond = ", Nbond)

  J=1.0
  tau = 1.0
  dt = 0.01
  print("J = ", J)
  print("tau = ", tau)
  print("dt = ", dt)
  ########################## ANALYTICAL ######################################

  start = time.time()
  if np.abs(field_i)<1.0 and np.abs(field_f)<1.0 and np.abs(field_f)<1e-10:
    _,list_loschmidt_echo = integrating_loschmidt_echo(J,field_i,field_f,tau,dt)
  end = time.time()
  print("time = ", end-start)

  ######################## INTERACTION #######################################

  start = time.time()
  S0,Sx,Sy,Sz = make_spin()
  list_site1,list_site2,list_Jzz = make_list_2(N)
  _,_, list_Jxx = make_list_2(N)
  list_Jz = make_list_1(N)
  list_Jx = make_list_1(N)
  list_Jx_stag = make_list_1_stag(N)
  list_Jz_stag = make_list_1_stag(N)
  print("site2",list_site2)
  print("Jzz",list_Jzz)
  print("Jx",list_Jx)
  end = time.time()
  print("time: prepare interaction",end - start)

  ####################### PREPARING HAMILTONIAN #############################
  start = time.time()
  Ham_zz = make_hamiltonian_2(S0,Sz,N,Nbond,list_site1,list_site2,list_Jzz)
  Ham_x = make_hamiltonian_1(S0,Sx,N,list_Jx)
  Ham_z = make_hamiltonian_1(S0,Sz,N,list_Jz)
  OP_xx = make_hamiltonian_2(S0,Sx,N,Nbond,list_site1,list_site2,list_Jxx)
  OP_zz = make_hamiltonian_2(S0,Sz,N,Nbond,list_site1,list_site2,list_Jzz)
  OP_x = make_hamiltonian_1(S0,Sx,N,list_Jx)
  OP_z = make_hamiltonian_1(S0,Sz,N,list_Jz)
  OP_X_stag = make_hamiltonian_1(S0,Sx,N,list_Jx_stag)
  OP_Z_stag = make_hamiltonian_1(S0,Sz,N,list_Jz_stag)
  ############### CORRELATION <mz(0)mz(1)> || <mx(0)mx(1)> ##################
  OP_Mz0Mz1 = copy.deepcopy( - OP_zz/N)
  OP_Mx0Mx1 = copy.deepcopy( - OP_xx/N)
  OP_Mx = copy.deepcopy ( -OP_x/N)
  OP_Mz = copy.deepcopy ( -OP_z/N)
  OP_Mx_stag = copy.deepcopy ( -OP_X_stag/N)
  OP_Mz_stag = copy.deepcopy ( -OP_Z_stag/N)
  end = time.time()
  print("time: prepare hamiltonian",end - start)
  ############### PREPARING : GS at T=0 #############################

  start =time.time()
  if np.abs(field_i)<1e-10:
    Ham0 = copy.deepcopy(OP_z) ##GS |+z>
  else:
    Ham0 = copy.deepcopy(Ham_zz + field_i*Ham_x)
  # Use eigsh from scipy.sparse.linalg directly to find eigenvalues and eigenvectors
  eig_val,eig_vec=scipy.sparse.linalg.eigsh(Ham0,which='SA',k=2)
  print("energy (t=0)",eig_val[0],eig_val[1])
  end = time.time()
  print("time : prepare initial state", end-start)
  ############### DYNAMICS CALCULATION ##################################

  start =time.time()
  h1=field_f
  vmax = 2.0*J*np.min([1.0,h1])
  tmax = tau/vmax
  Nsteps = int(tmax/dt + 0.1)+1
  timei = 0.0
  timef = tmax
  steps = Nsteps
  Hamiltonian = copy.deepcopy(Ham_zz + field_f*Ham_x + field_f*Ham_z)
  psi0 = copy.deepcopy( eig_vec[:,0])
  ret = scipy.sparse.linalg.expm_multiply((-1j)*Hamiltonian,eig_vec[:,0],start=timei,stop=timef,num=steps,endpoint=True)
  ene0 = [(np.dot(np.conjugate(ret[i]),Ham0.dot(ret[i]))/np.dot(np.conjugate(ret[i]),ret[i])).real for i in range(steps)]
  ene= [(np.dot(np.conjugate(ret[i]),Hamiltonian.dot(ret[i]))/np.dot(np.conjugate(ret[i]),ret[i])).real for i in range(steps)]
  mx0mx1 = [(np.dot(np.conjugate(ret[i]),OP_Mx0Mx1.dot(ret[i]))/np.dot(np.conjugate(ret[i]),ret[i])).real for i in range(steps)]
  mz0mz1 = [(np.dot(np.conjugate(ret[i]),OP_Mz0Mz1.dot(ret[i]))/np.dot(np.conjugate(ret[i]),ret[i])).real for i in range(steps)]
  mx = [(np.dot(np.conjugate(ret[i]),OP_Mx.dot(ret[i]))/np.dot(np.conjugate(ret[i]),ret[i])).real for i in range(steps)]
  mz = [(np.dot(np.conjugate(ret[i]),OP_Mz.dot(ret[i]))/np.dot(np.conjugate(ret[i]),ret[i])).real for i in range(steps)]
  mx_stag = [(np.dot(np.conjugate(ret[i]),OP_Mx_stag.dot(ret[i]))/np.dot(np.conjugate(ret[i]),ret[i])).real for i in range(steps)]
  mz_stag = [(np.dot(np.conjugate(ret[i]),OP_Mz_stag.dot(ret[i]))/np.dot(np.conjugate(ret[i]),ret[i])).real for i in range(steps)]
  loschmidt_echo = [(np.abs(np.dot(np.conjugate(ret[i]),psi0))**2 / np.dot(np.conjugate(ret[i]),ret[i]) / np.dot(np.conjugate(psi0),psi0)).real for i in range(steps)]
  print("ene0",ene0)
  print("ene",ene)
  print("mz0mz1",mz0mz1)
  print("mx0mx1",mx0mx1)
  print("mx",mx)
  print("mz",mz)
  print("mx_stag",mx_stag)
  print("mz_stag",mz_stag)
  print("loschmidt_echo",loschmidt_echo)
  print("The density imbalance = ",(4/N)*mz0mz1)
  end = time.time()
  print("time : calculate dynamics ", end-start)

if __name__ == "__main__":
  ############### IMPORTING SYSTEM SIZE IN PLACE OF 30 #########################
  sys.argv = ['myscript.py','-N','20']
  main()