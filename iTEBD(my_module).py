# -*- coding: utf-8 -*-
"""my_module.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RfbxrXWFOi-rnzLmaK2lt6i0xc9bp7J0

#**Implementing a Matrix Product State**
"""

from google.colab import drive
drive.mount('/content/drive')

import pylab as pl

import numpy as np
from scipy.linalg import svd



class SimpleMPS:

    def __init__(self, Bs, Ss, bc='finite'):
        assert bc in ['finite', 'infinite']
        self.Bs = Bs
        self.Ss = Ss
        self.bc = bc
        self.L = len(Bs)
        self.nbonds = self.L - 1 if self.bc == 'finite' else self.L

    def copy(self):
        return SimpleMPS([B.copy() for B in self.Bs], [S.copy() for S in self.Ss], self.bc)

    def get_theta1(self, i):

        return np.tensordot(np.diag(self.Ss[i]), self.Bs[i], [1, 0])  # vL [vL'], [vL] i vR

    def get_theta2(self, i):

        j = (i + 1) % self.L
        return np.tensordot(self.get_theta1(i), self.Bs[j], [2, 0])  # vL i [vR], [vL] j vR

    def get_chi(self):

        return [self.Bs[i].shape[2] for i in range(self.nbonds)]

    def site_expectation_value(self, op):

        result = []
        for i in range(self.L):
            theta = self.get_theta1(i)  # vL i vR
            op_theta = np.tensordot(op, theta, axes=(1, 1))  # i [i*], vL [i] vR
            result.append(np.tensordot(theta.conj(), op_theta, [[0, 1, 2], [1, 0, 2]]))
            # [vL*] [i*] [vR*], [i] [vL] [vR]
        return np.real_if_close(result)

    def bond_expectation_value(self, op):

        result = []
        for i in range(self.nbonds):
            theta = self.get_theta2(i)  # vL i j vR
            op_theta = np.tensordot(op[i], theta, axes=([2, 3], [1, 2]))
            # i j [i*] [j*], vL [i] [j] vR
            result.append(np.tensordot(theta.conj(), op_theta, [[0, 1, 2, 3], [2, 0, 1, 3]]))
            # [vL*] [i*] [j*] [vR*], [i] [j] [vL] [vR]
        return np.real_if_close(result)

    def entanglement_entropy(self):

        bonds = range(1, self.L) if self.bc == 'finite' else range(0, self.L)
        result = []
        for i in bonds:
            S = self.Ss[i]
            S = S[S > 1.e-20]  # 0*log(0) should give 0 and won't contribute to the sum
            # avoid warning or NaN by discarding the very small values of S
            S2 = S * S
            assert abs(np.linalg.norm(S) - 1.) < 1.e-13
            result.append(-np.sum(S2 * np.log(S2)))
        return np.array(result)

    def correlation_length(self):
        from scipy.sparse.linalg import eigs
        if self.get_chi()[0] > 100:
            warnings.warn("Skip calculating correlation_length() for large chi: could take long")
            return -1.
        assert self.bc == 'infinite'  # works only in the infinite case
        B = self.Bs[0]  # vL i vR
        chi = B.shape[0]
        T = np.tensordot(B, np.conj(B), axes=(1, 1))  # vL [i] vR, vL* [i*] vR*
        T = np.transpose(T, [0, 2, 1, 3])  # vL vL* vR vR*
        for i in range(1, self.L):
            B = self.Bs[i]
            T = np.tensordot(T, B, axes=(2, 0))  # vL vL* [vR] vR*, [vL] i vR
            T = np.tensordot(T, np.conj(B), axes=([2, 3], [0, 1]))
            # vL vL* [vR*] [i] vR, [vL*] [i*] vR*
        T = np.reshape(T, (chi**2, chi**2))
        # Obtain the 2nd largest eigenvalue
        eta = eigs(T, k=2, which='LM', return_eigenvectors=False, ncv=20)
        xi =  -self.L / np.log(np.min(np.abs(eta)))
        if xi > 1000.:
            return np.inf
        return xi

    def correlation_function(self, op_i, i, op_j, j):
        # assert i < j
        theta = self.get_theta1(i) # vL i vR
        C = np.tensordot(op_i, theta, axes=(1, 1)) # i [i*], vL [i] vR
        C = np.tensordot(theta.conj(), C, axes=([0, 1], [1, 0]))  # [vL*] [i*] vR*, [i] [vL] vR
        for k in range(i + 1, j):
            k = k % self.L
            B = self.Bs[k]  # vL k vR
            C = np.tensordot(C, B, axes=(1, 0)) # vR* [vR], [vL] k vR
            C = np.tensordot(B.conj(), C, axes=([0, 1], [0, 1])) # [vL*] [k*] vR*, [vR*] [k] vR
        j = j % self.L
        B = self.Bs[j]  # vL k vR
        C = np.tensordot(C, B, axes=(1, 0)) # vR* [vR], [vL] j vR
        C = np.tensordot(op_j, C, axes=(1, 1))  # j [j*], vR* [j] vR
        C = np.tensordot(B.conj(), C, axes=([0, 1, 2], [1, 0, 2])) # [vL*] [j*] [vR*], [j] [vR*] [vR]
        return C


def init_FM_MPS(L, d=2, bc='finite'):

    B = np.zeros([1, d, 1], dtype=float)
    B[0, 0, 0] = 1.
    S = np.ones([1], dtype=float)
    Bs = [B.copy() for i in range(L)]
    Ss = [S.copy() for i in range(L)]
    return SimpleMPS(Bs, Ss, bc=bc)


def init_Neel_MPS(L, d=2, bc='finite'):

    S = np.ones([1], dtype=float)
    Bs = []
    for i in range(L):
        B = np.zeros([1, d, 1], dtype=float)
        if i % 2 == 0:
            B[0, 0, 0] = 1.
        else:
            B[0, -1, 0] = 1.
        Bs.append(B)
    Ss = [S.copy() for i in range(L)]
    return SimpleMPS(Bs, Ss, bc=bc)


def split_truncate_theta(theta, chi_max, eps):

    chivL, dL, dR, chivR = theta.shape
    theta = np.reshape(theta, [chivL * dL, dR * chivR])
    X, Y, Z = svd(theta, full_matrices=False)
    # truncate
    chivC = min(chi_max, np.sum(Y > eps))
    assert chivC >= 1
    piv = np.argsort(Y)[::-1][:chivC]  # keep the largest `chivC` singular values
    X, Y, Z = X[:, piv], Y[piv], Z[piv, :]
    # renormalize
    S = Y / np.linalg.norm(Y)  # == Y/sqrt(sum(Y**2))
    # split legs of X and Z
    A = np.reshape(X, [chivL, dL, chivC])
    B = np.reshape(Z, [chivC, dR, chivR])
    return A, S, B

class XXChain:
    """Simple class generating the Hamiltonian of the
    The Hamiltonian reads
    .. math ::
        H = - J \\sum_{i} \\sigma^x_i \\sigma^x_{i+1} - g \\sum_{i} \\sigma^z_i
    """
    def __init__(self, L, hs, bc='finite'):
        assert bc in ['finite', 'infinite']
        self.L, self.d, self.bc = L, 2, bc
        self.hs = hs
        self.sigmax = np.array([[0., 1.], [1., 0.]])  # Pauli X
        self.sigmay = np.array([[0., -1j], [1j, 0.]]) # Pauli Y
        self.sigmaz = np.array([[1., 0.], [0., -1.]]) # Pauli Z
        self.id = np.eye(2)
        self.init_H_bonds()
        self.init_H_mpo()

    def init_H_bonds(self):
        """Initialize `H_bonds` hamiltonian."""
        sx, sy, sz, id = self.sigmax, self.sigmay, self.sigmaz, self.id
        d = self.d
        nbonds = self.L - 1 if self.bc == 'finite' else self.L
        H_list = []
        for i in range(nbonds):
            hL = hR = 0.5 * self.hs
            if self.bc == 'finite':
                if i == 0:
                    hL = self.hs
                if i + 1 == self.L - 1:
                    hR = self.hs
            H_bond = np.kron(sx, sx) + np.kron(sy, sy)
            H_bond = H_bond - hL * (-1)**i * np.kron(sz, id) - hR * (-1)**(i+1) * np.kron(id, sz)
            # H_bond has legs ``i, j, i*, j*``
            H_list.append(np.reshape(H_bond, [d, d, d, d]))
        self.H_bonds = H_list

    # (note: not required for TEBD)
    def init_H_mpo(self):
        """Initialize `H_mpo` Hamiltonian."""
        w_list = []
        for i in range(self.L):
            w = np.zeros((4, 4, self.d, self.d), dtype=complex)
            w[0, 0] = w[3, 3] = self.id

            raise NotImplementedError("add further entries here")

            w_list.append(w)
        self.H_mpo = w_list

model = XXChain(9, 4., bc='finite')

import numpy as np


class TFIModel:

    def __init__(self, L, J, g, bc='finite'):
        assert bc in ['finite', 'infinite']
        self.L, self.d, self.bc = L, 2, bc
        self.J, self.g = J, g
        self.sigmax = np.array([[0., 1.], [1., 0.]])
        self.sigmay = np.array([[0., -1j], [1j, 0.]])
        self.sigmaz = np.array([[1., 0.], [0., -1.]])
        self.id = np.eye(2)
        self.init_H_bonds()
        self.init_H_mpo()

    def init_H_bonds(self):

        X, Z, Id = self.sigmax, self.sigmaz, self.id
        d = self.d
        nbonds = self.L - 1 if self.bc == 'finite' else self.L
        H_list = []
        for i in range(nbonds):
            gL = gR = 0.5 * self.g
            if self.bc == 'finite':
                if i == 0:
                    gL = self.g
                if i + 1 == self.L - 1:
                    gR = self.g
            H_bond = -self.J * np.kron(Z, Z) - gL * np.kron(X, Id) - gR * np.kron(Id, X)
            # note: kron is short-hand for outer product + grouping bra and ket legs.
            # H_bond has legs ``i, j, i*, j*``
            H_list.append(np.reshape(H_bond, [d, d, d, d]))
        self.H_bonds = H_list

    # (note: not required for TEBD)
    def init_H_mpo(self):

        w_list = []
        for i in range(self.L):
            w = np.zeros((3, 3, self.d, self.d), dtype=float)
            w[0, 0] = w[2, 2] = self.id
            w[0, 1] = self.sigmaz
            w[0, 2] = -self.g * self.sigmax
            w[1, 2] = -self.J * self.sigmaz
            w_list.append(w)
        self.H_mpo = w_list

import numpy as np
from scipy.linalg import expm
# from .a_mps import split_truncate_theta


def calc_U_bonds(H_bonds, dt):

    d = H_bonds[0].shape[0]
    U_bonds = []
    for H in H_bonds:
        H = np.reshape(H, [d * d, d * d])
        U = expm(-dt * H)
        U_bonds.append(np.reshape(U, [d, d, d, d]))
    return U_bonds


def run_TEBD(psi, U_bonds, N_steps, chi_max, eps):

    Nbonds = psi.L - 1 if psi.bc == 'finite' else psi.L
    assert len(U_bonds) == Nbonds
    for n in range(N_steps):
        for k in [0, 1]:  # even, odd
            for i_bond in range(k, Nbonds, 2):
                update_bond(psi, i_bond, U_bonds[i_bond], chi_max, eps)
    # done


def update_bond(psi, i, U_bond, chi_max, eps):

    j = (i + 1) % psi.L
    # construct theta matrix
    theta = psi.get_theta2(i)  # vL i j vR
    # apply U
    Utheta = np.tensordot(U_bond, theta, axes=([2, 3], [1, 2]))  # i j [i*] [j*], vL [i] [j] vR
    Utheta = np.transpose(Utheta, [2, 0, 1, 3])  # vL i j vR
    # split and truncate
    Ai, Sj, Bj = split_truncate_theta(Utheta, chi_max, eps)
    # put back into MPS
    Gi = np.tensordot(np.diag(psi.Ss[i]**(-1)), Ai, axes=(1, 0))  # vL [vL*], [vL] i vC
    psi.Bs[i] = np.tensordot(Gi, np.diag(Sj), axes=(2, 0))  # vL i [vC], [vC] vC
    psi.Ss[j] = Sj  # vC
    psi.Bs[j] = Bj  # vC j vR


def example_TEBD_gs_tf_ising_finite(L, g, chi_max=30):
    print("finite TEBD, imaginary time evolution, transverse field Ising")
    print("L={L:d}, g={g:.2f}".format(L=L, g=g))
    # from . import a_mps
    # from . import b_model
    model =TFIModel(L=L, J=1., g=g, bc='finite')
    psi = init_FM_MPS(model.L, model.d, model.bc)
    for dt in [0.1,0.01,0.001,1.e-5,1.e-6]:
        U_bonds = calc_U_bonds(model.H_bonds, dt)
        run_TEBD(psi, U_bonds, N_steps=500, chi_max=chi_max, eps=1.e-10)
        E = np.sum(psi.bond_expectation_value(model.H_bonds))
        print("dt = {dt:.5f}: E = {E:.13f}".format(dt=dt, E=E))
    print("final bond dimensions: ", psi.get_chi())
    mag_x = np.sum(psi.site_expectation_value(model.sigmax))
    mag_z = np.sum(psi.site_expectation_value(model.sigmaz))
    print("magnetization in X = {mag_x:.5f}".format(mag_x=mag_x))
    print("magnetization in Z = {mag_z:.5f}".format(mag_z=mag_z))
    print("entanglement entropy = ", psi.entanglement_entropy())
    # print("correlation length = ", psi.correlation_length())
    return E, psi.entanglement_entropy(), psi.get_chi()


a,b,c=example_TEBD_gs_tf_ising_finite(L=80, g=1.0)

b_reshaped=b.reshape(len(b),-1)
pl.pcolor(b_reshaped,cmap="jet")
pl.show()

def example_TEBD_gs_tf_ising_finite_new(L, g, chi_max=30):
    sigmaz = np.array([[1., 0.], [0., -1.]])
    print("finite TEBD, imaginary time evolution, transverse field Ising")
    print("L={L:d}, g={g:.2f}".format(L=L, g=g))
    # from . import a_mps
    # from . import b_model
    model =TFIModel(L=L, J=1., g=g, bc='finite')
    psi = init_FM_MPS(model.L, model.d, model.bc)
    for dt in [0.1,0.01,0.001,1.e-5,1.e-6]:
        U_bonds = calc_U_bonds(model.H_bonds, dt)
        run_TEBD(psi, U_bonds, N_steps=500, chi_max=chi_max, eps=1.e-10)
        E = np.sum(psi.bond_expectation_value(model.H_bonds))
        print("dt = {dt:.5f}: E = {E:.13f}".format(dt=dt, E=E))
    print("final bond dimensions: ", psi.get_chi())
    mag_x = np.sum(psi.site_expectation_value(model.sigmax))
    mag_z = np.sum(psi.site_expectation_value(model.sigmaz))
    print("magnetization in X = {mag_x:.5f}".format(mag_x=mag_x))
    print("magnetization in Z = {mag_z:.5f}".format(mag_z=mag_z))
    print("entanglement entropy = ", psi.entanglement_entropy())
    # print("correlation length = ", psi.correlation_length())
    return psi.correlation_function(sigmaz,5,sigmaz,6)

d=example_TEBD_gs_tf_ising_finite_new(L=10, g=1.0)

"""**` Calculation for correlation-function`**

"""

L=[20,30,40,50,60,70,80]
d_new=[0 for i in range(len(L))]
for i,j in enumerate(L):
  d_new[i]=example_TEBD_gs_tf_ising_finite_new(L=j,g=1.0)

import matplotlib.pyplot as plt
plt.xlabel("site number")
plt.ylabel("correlation function")
plt.plot(L,d_new)

"""**Calculation for magnetization m^2**"""

def example_TEBD_gs_tf_ising_finite_new(L, g, chi_max=30):
    sigmaz = np.array([[1., 0.], [0., -1.]])
    print("finite TEBD, imaginary time evolution, transverse field Ising")
    print("L={L:d}, g={g:.2f}".format(L=L, g=g))
    # from . import a_mps
    # from . import b_model
    model =TFIModel(L=L, J=1., g=g, bc='finite')
    psi = init_FM_MPS(model.L, model.d, model.bc)
    for dt in [10e-3,2*10e-3,3*10e-3]:
        U_bonds = calc_U_bonds(model.H_bonds, dt)
        run_TEBD(psi, U_bonds, N_steps=500, chi_max=chi_max, eps=1.e-10)
        E = np.sum(psi.bond_expectation_value(model.H_bonds))
        print("dt = {dt:.5f}: E = {E:.13f}".format(dt=dt, E=E))
    print("final bond dimensions: ", psi.get_chi())
    mag_x = np.sum(psi.site_expectation_value(model.sigmax))
    mag_z = np.sum(psi.site_expectation_value(model.sigmaz))
    print("magnetization in X = {mag_x:.5f}".format(mag_x=mag_x))
    print("magnetization in Z = {mag_z:.5f}".format(mag_z=mag_z))
    print("entanglement entropy = ", psi.entanglement_entropy())
    # print("correlation length = ", psi.correlation_length())
    return psi.correlation_function(sigmaz,5,sigmaz,6)
L=[20,30,40,50,60,70,80]
d_new=[0 for i in range(len(L))]
for i,j in enumerate(L):
  d_new[i]=example_TEBD_gs_tf_ising_finite_new(L=j,g=1.0)

plt.xlabel("site number")
plt.ylabel("magnetization")
plt.plot(L,d_new)

d=[[],[]]
for i in range(len(b)):
  d[1].append(b[i])
plt.plot(d[1],c)

len(c)

import matplotlib.pyplot as plt
d1=[[],[]]
site_ar=[50,90]
for i in site_ar:
  for j in range(len(site_ar)):
    a,b1,c=example_TEBD_gs_tf_ising_finite(L=i, g=1.0);
    r=np.arange(len(b1))
    for c1 in range(len(b1)):
      d1[j].append(b1[c1])
# plt.plot(b1,r,label="L="+str(i))
# plt.legend()
# plt.show()

for i in range(2):
  plt.plot(d1[i][0:89],c,label="L="+str(site_ar[i]))
plt.legend()
plt.show()

import seaborn as sns
sns.heatmap(np.reshape(d1[1][0:64],(8,8)), cmap="YlGnBu", annot=True, fmt=".2f", cbar=True)

import seaborn as sns
sns.heatmap(np.reshape(d1[0][64:128],(8,8)), cmap="YlGnBu", annot=True, fmt=".3f", cbar=True)

"""#**Suzuki Trotter Decomposition**
* **First Order**
"""

!pip install ncon
# from ncon import ncon

import numpy as np


class TFIModel:

    def __init__(self, L, J, g, bc='finite'):
        assert bc in ['finite', 'infinite']
        self.L, self.d, self.bc = L, 2, bc
        self.J, self.g = J, g
        self.sigmax = np.array([[0., 1.], [1., 0.]])
        self.sigmay = np.array([[0., -1j], [1j, 0.]])
        self.sigmaz = np.array([[1., 0.], [0., -1.]])
        self.id = np.eye(2)
        self.init_H_bonds()
        self.init_H_mpo()
        self.init_H_bonds_1()
        self.init_H_bonds_2()

    def init_H_bonds_1(self):
      Z=self.sigmaz
      d = self.d
      nbonds = self.L - 1 if self.bc == 'finite' else self.L
      H_list = []
      H_bond1=-self.J * np.kron(Z, Z)
      H_list.append(np.reshape(H_bond1, [d, d, d, d]))
      self.H_bonds_1 = H_list
    def init_H_bonds_2(self):
      X=self.sigmax
      d = self.d
      nbonds = self.L - 1 if self.bc == 'finite' else self.L
      H_list = []
      for i in range(nbonds):
        gL = gR = 0.5 * self.g
        if self.bc == 'finite':
          if i == 0:
            gL = self.g
            if i + 1 == self.L - 1:
              gR = self.g
        H_bond2=-gL*np.kron(X,self.id)-gR*np.kron(self.id,X)
        H_list.append(np.reshape(H_bond2, [d, d, d, d]))
      self.H_bonds_2 = H_list
    def init_H_bonds(self):

        X, Z, Id = self.sigmax, self.sigmaz, self.id
        d = self.d
        nbonds = self.L - 1 if self.bc == 'finite' else self.L
        H_list = []
        for i in range(nbonds):
            gL = gR = 0.5 * self.g
            if self.bc == 'finite':
                if i == 0:
                    gL = self.g
                if i + 1 == self.L - 1:
                    gR = self.g
            H_bond = -self.J * np.kron(Z, Z) - gL * np.kron(X, Id) - gR * np.kron(Id, X)
            # note: kron is short-hand for outer product + grouping bra and ket legs.
            # H_bond has legs ``i, j, i*, j*``
            H_list.append(np.reshape(H_bond, [d, d, d, d]))
        self.H_bonds = H_list

    # (note: not required for TEBD)
    def init_H_mpo(self):

        w_list = []
        for i in range(self.L):
            w = np.zeros((3, 3, self.d, self.d), dtype=float)
            w[0, 0] = w[2, 2] = self.id
            w[0, 1] = self.sigmaz
            w[0, 2] = -self.g * self.sigmax
            w[1, 2] = -self.J * self.sigmaz
            w_list.append(w)
        self.H_mpo = w_list

# from ncon import ncon

import numpy as np
from scipy.linalg import expm
# from .a_mps import split_truncate_theta


import numpy as np
from scipy.linalg import expm

def calc_U_bonds(H_bonds1, H_bonds2, dt):
    """
    Calculates the time evolution operators for bonds.

    Args:
        H_bonds1: List of bond Hamiltonians for the first term.
        H_bonds2: List of bond Hamiltonians for the second term.
        dt: Time step.

    Returns:
        List of time evolution operators for bonds.
    """
    d = H_bonds1[0].shape[0]
    U_bonds = []
    for H in H_bonds1:  # Assume H_bonds1 has one element
        H = np.reshape(H, [d * d, d * d])
        U1 = expm(-dt * H)  # U1 for the first term

    # Modified: Loop through H_bonds2 to create the full list of U_bonds
    for j, H in enumerate(H_bonds2):
        H = np.reshape(H, [d * d, d * d])
        U2 = expm(-dt * H)  # U2 for the second term
    for H in H_bonds1:  # Assume H_bonds1 has one element
        H = np.reshape(H, [d * d, d * d])
        U3 = expm(-dt * H)  # U1 for the first term
    for j, H in enumerate(H_bonds2):
        H = np.reshape(H, [d * d, d * d])
        U4 = expm(-dt * H)  # U2 for the second term
    for H in H_bonds1:  # Assume H_bonds1 has one element
        H = np.reshape(H, [d * d, d * d])
        U5 = expm(-dt * H)  # U1 for the first term
    for j, H in enumerate(H_bonds2):
        H = np.reshape(H, [d * d, d * d])
        U6 = expm(-dt * H)  # U2 for the second term
        U_bonds.append(np.reshape(U1, [d, d, d, d]) * np.reshape(U2, [d, d, d, d])*np.reshape(U3, [d, d, d, d])*np.reshape(U4, [d, d, d, d])*np.reshape(U5, [d, d, d, d])*np.reshape(U6, [d, d, d, d]))

    return U_bonds

def run_TEBD(psi, U_bonds, N_steps, chi_max, eps):

    Nbonds = psi.L - 1 if psi.bc == 'finite' else psi.L
    assert len(U_bonds) == Nbonds
    for n in range(N_steps):
        for k in [0, 1]:  # even, odd
            for i_bond in range(k, Nbonds, 2):
                update_bond(psi, i_bond, U_bonds[i_bond], chi_max, eps)
    # done


def update_bond(psi, i, U_bond, chi_max, eps):

    j = (i + 1) % psi.L
    # construct theta matrix
    theta = psi.get_theta2(i)  # vL i j vR
    # apply U
    Utheta = np.tensordot(U_bond, theta, axes=([2, 3], [1, 2]))  # i j [i*] [j*], vL [i] [j] vR
    Utheta = np.transpose(Utheta, [2, 0, 1, 3])  # vL i j vR
    # split and truncate
    Ai, Sj, Bj = split_truncate_theta(Utheta, chi_max, eps)
    # put back into MPS
    Gi = np.tensordot(np.diag(psi.Ss[i]**(-1)), Ai, axes=(1, 0))  # vL [vL*], [vL] i vC
    psi.Bs[i] = np.tensordot(Gi, np.diag(Sj), axes=(2, 0))  # vL i [vC], [vC] vC
    psi.Ss[j] = Sj  # vC
    psi.Bs[j] = Bj  # vC j vR


def example_TEBD_gs_tf_ising_finite(L, g, chi_max=30):
    print("finite TEBD, imaginary time evolution, transverse field Ising")
    print("L={L:d}, g={g:.2f}".format(L=L, g=g))
    # from . import a_mps
    # from . import b_model
    model =TFIModel(L=L, J=1., g=g, bc='finite')
    psi = init_FM_MPS(model.L, model.d, model.bc)
    for dt in [10e-3,2*10e-3,3*10e-3]:
        U_bonds = calc_U_bonds(model.H_bonds_1,model.H_bonds_2, dt)
        run_TEBD(psi, U_bonds, N_steps=500, chi_max=chi_max, eps=1.e-10)
        E = np.sum(psi.bond_expectation_value(model.H_bonds))
        print("dt = {dt:.5f}: E = {E:.13f}".format(dt=dt, E=E))
    print("final bond dimensions: ", psi.get_chi())
    mag_x = np.sum(psi.site_expectation_value(model.sigmax))
    mag_z = np.sum(psi.site_expectation_value(model.sigmaz))
    print("magnetization in X = {mag_x:.5f}".format(mag_x=mag_x))
    print("magnetization in Z = {mag_z:.5f}".format(mag_z=mag_z))
    print("entanglement entropy = ", psi.entanglement_entropy())
    # print("correlation length = ", psi.correlation_length())
    return E, psi.entanglement_entropy(), psi.get_chi()


a,b,c=example_TEBD_gs_tf_ising_finite(L=80, g=1.0)

b_reshaped=b.reshape(len(b),-1)
pl.pcolor(b_reshaped,cmap="jet")
pl.show()

"""#**Trotter Decomposition**
* **Second order**
"""

# from ncon import ncon

import numpy as np
from scipy.linalg import expm
# from .a_mps import split_truncate_theta


import numpy as np
from scipy.linalg import expm

def calc_U_bonds(H_bonds1, H_bonds2, dt):
    """
    Calculates the time evolution operators for bonds.

    Args:
        H_bonds1: List of bond Hamiltonians for the first term.
        H_bonds2: List of bond Hamiltonians for the second term.
        dt: Time step.

    Returns:
        List of time evolution operators for bonds.
    """
    d = H_bonds1[0].shape[0]
    U_bonds = []
    for H in H_bonds1:  # Assume H_bonds1 has one element
        H = np.reshape(H, [d * d, d * d])
        U1 = expm(-dt/2 * H)  # U1 for the first term

    # Modified: Loop through H_bonds2 to create the full list of U_bonds
    for j, H in enumerate(H_bonds2):
        H = np.reshape(H, [d * d, d * d])
        U2 = expm(-dt * H)  # U2 for the second term
    for H in H_bonds1:  # Assume H_bonds1 has one element
        H = np.reshape(H, [d * d, d * d])
        U3 = expm(-dt/2 * H)  # U1 for the first term
    for j, H in enumerate(H_bonds2):
        H = np.reshape(H, [d * d, d * d])
        U4 = expm(-dt/2 * H)  # U2 for the second term
    for H in H_bonds1:  # Assume H_bonds1 has one element
        H = np.reshape(H, [d * d, d * d])
        U5 = expm(-dt * H)  # U1 for the first term
    for j, H in enumerate(H_bonds2):
        H = np.reshape(H, [d * d, d * d])
        U6 = expm(-dt/2 * H)  # U2 for the second term
        U_bonds.append(np.reshape(U1, [d, d, d, d]) * np.reshape(U2, [d, d, d, d])*np.reshape(U3, [d, d, d, d])*np.reshape(U4, [d, d, d, d])*np.reshape(U5, [d, d, d, d])*np.reshape(U6, [d, d, d, d]))

    return U_bonds

def run_TEBD(psi, U_bonds, N_steps, chi_max, eps):

    Nbonds = psi.L - 1 if psi.bc == 'finite' else psi.L
    assert len(U_bonds) == Nbonds
    for n in range(N_steps):
        for k in [0, 1]:  # even, odd
            for i_bond in range(k, Nbonds, 2):
                update_bond(psi, i_bond, U_bonds[i_bond], chi_max, eps)
    # done


def update_bond(psi, i, U_bond, chi_max, eps):

    j = (i + 1) % psi.L
    # construct theta matrix
    theta = psi.get_theta2(i)  # vL i j vR
    # apply U
    Utheta = np.tensordot(U_bond, theta, axes=([2, 3], [1, 2]))  # i j [i*] [j*], vL [i] [j] vR
    Utheta = np.transpose(Utheta, [2, 0, 1, 3])  # vL i j vR
    # split and truncate
    Ai, Sj, Bj = split_truncate_theta(Utheta, chi_max, eps)
    # put back into MPS
    Gi = np.tensordot(np.diag(psi.Ss[i]**(-1)), Ai, axes=(1, 0))  # vL [vL*], [vL] i vC
    psi.Bs[i] = np.tensordot(Gi, np.diag(Sj), axes=(2, 0))  # vL i [vC], [vC] vC
    psi.Ss[j] = Sj  # vC
    psi.Bs[j] = Bj  # vC j vR


def example_TEBD_gs_tf_ising_finite(L, g, chi_max=30):
    print("finite TEBD, imaginary time evolution, transverse field Ising")
    print("L={L:d}, g={g:.2f}".format(L=L, g=g))
    # from . import a_mps
    # from . import b_model
    model =TFIModel(L=L, J=1., g=g, bc='finite')
    psi = init_FM_MPS(model.L, model.d, model.bc)
    for dt in [0.1,0.01,0.001,1.e-5,1.e-6]:
        U_bonds = calc_U_bonds(model.H_bonds_1,model.H_bonds_2, dt)
        run_TEBD(psi, U_bonds, N_steps=500, chi_max=chi_max, eps=1.e-10)
        E = np.sum(psi.bond_expectation_value(model.H_bonds))
        print("dt = {dt:.5f}: E = {E:.13f}".format(dt=dt, E=E))
    print("final bond dimensions: ", psi.get_chi())
    mag_x = np.sum(psi.site_expectation_value(model.sigmax))
    mag_z = np.sum(psi.site_expectation_value(model.sigmaz))
    print("magnetization in X = {mag_x:.5f}".format(mag_x=mag_x))
    print("magnetization in Z = {mag_z:.5f}".format(mag_z=mag_z))
    print("entanglement entropy = ", psi.entanglement_entropy())
    # print("correlation length = ", psi.correlation_length())
    return E, psi.entanglement_entropy(), psi.get_chi()


a,b,c=example_TEBD_gs_tf_ising_finite(L=80, g=1.0)

"""#**Transverse Longitudinal ising Model**
* **Entanglement Entropy**
"""

import pylab as pl
import numpy as np
from scipy.linalg import svd

# Example with two lists
list1 = [1, 2, 3]
list2 = [4, 5, 6]

zipped = zip(list1, list2)
emp=[]
zipped_list = list(zipped)
for i in range(len(zipped_list)):
  emp.append(zipped_list[i][0] + zipped_list[i][1])
emp

"""# **Transverse and Longitudinal field ising model**"""

import numpy as np
from scipy.linalg import svd
class SimpleMPS:


    def __init__(self, Bs, Ss, bc='finite'):
        assert bc in ['finite', 'infinite']
        self.Bs = Bs
        self.Ss = Ss
        self.bc = bc
        self.L = len(Bs)
        self.nbonds = self.L - 1 if self.bc == 'finite' else self.L

    def copy(self):
        return SimpleMPS([B.copy() for B in self.Bs], [S.copy() for S in self.Ss], self.bc)

    def get_theta1(self, i):

        return np.tensordot(np.diag(self.Ss[i]), self.Bs[i], [1, 0])  # vL [vL'], [vL] i vR

    def get_theta2(self, i):

        j = (i + 1) % self.L
        return np.tensordot(self.get_theta1(i), self.Bs[j], [2, 0])  # vL i [vR], [vL] j vR

    def get_chi(self):

        return [self.Bs[i].shape[2] for i in range(self.nbonds)]

    def site_expectation_value(self, op):

        result = []
        for i in range(self.L):
            theta = self.get_theta1(i)  # vL i vR
            op_theta = np.tensordot(op, theta, axes=(1, 1))  # i [i*], vL [i] vR
            result.append(np.tensordot(theta.conj(), op_theta, [[0, 1, 2], [1, 0, 2]]))
            # [vL*] [i*] [vR*], [i] [vL] [vR]
        return np.real_if_close(result)

    def bond_expectation_value(self, op):

        result = []
        for i in range(self.nbonds):
            theta = self.get_theta2(i)  # vL i j vR
            op_theta = np.tensordot(op[i], theta, axes=([2, 3], [1, 2]))
            # i j [i*] [j*], vL [i] [j] vR
            result.append(np.tensordot(theta.conj(), op_theta, [[0, 1, 2, 3], [2, 0, 1, 3]]))
            # [vL*] [i*] [j*] [vR*], [i] [j] [vL] [vR]
        return np.real_if_close(result)

    def entanglement_entropy(self):

        bonds = range(1, self.L) if self.bc == 'finite' else range(0, self.L)
        result = []
        for i in bonds:
            S = self.Ss[i]
            S = S[S > 1.e-20]  # 0*log(0) should give 0 and won't contribute to the sum
            # avoid warning or NaN by discarding the very small values of S
            S2 = S * S
            assert abs(np.linalg.norm(S) - 1.) < 1.e-13
            result.append(-np.sum(S2 * np.log(S2)))
        return np.array(result)

    def correlation_length(self):
        from scipy.sparse.linalg import eigs
        if self.get_chi()[0] > 100:
            warnings.warn("Skip calculating correlation_length() for large chi: could take long")
            return -1.
        assert self.bc == 'infinite'  # works only in the infinite case
        B = self.Bs[0]  # vL i vR
        chi = B.shape[0]
        T = np.tensordot(B, np.conj(B), axes=(1, 1))  # vL [i] vR, vL* [i*] vR*
        T = np.transpose(T, [0, 2, 1, 3])  # vL vL* vR vR*
        for i in range(1, self.L):
            B = self.Bs[i]
            T = np.tensordot(T, B, axes=(2, 0))  # vL vL* [vR] vR*, [vL] i vR
            T = np.tensordot(T, np.conj(B), axes=([2, 3], [0, 1]))
            # vL vL* [vR*] [i] vR, [vL*] [i*] vR*
        T = np.reshape(T, (chi**2, chi**2))
        # Obtain the 2nd largest eigenvalue
        eta = eigs(T, k=2, which='LM', return_eigenvectors=False, ncv=20)
        xi =  -self.L / np.log(np.min(np.abs(eta)))
        if xi > 1000.:
            return np.inf
        return xi

    def correlation_function(self, op_i, i, op_j, j):
        # assert i < j
        theta = self.get_theta1(i) # vL i vR
        C = np.tensordot(op_i, theta, axes=(1, 1)) # i [i*], vL [i] vR
        C = np.tensordot(theta.conj(), C, axes=([0, 1], [1, 0]))  # [vL*] [i*] vR*, [i] [vL] vR
        for k in range(i + 1, j):
            k = k % self.L
            B = self.Bs[k]  # vL k vR
            C = np.tensordot(C, B, axes=(1, 0)) # vR* [vR], [vL] k vR
            C = np.tensordot(B.conj(), C, axes=([0, 1], [0, 1])) # [vL*] [k*] vR*, [vR*] [k] vR
        j = j % self.L
        B = self.Bs[j]  # vL k vR
        C = np.tensordot(C, B, axes=(1, 0)) # vR* [vR], [vL] j vR
        C = np.tensordot(op_j, C, axes=(1, 1))  # j [j*], vR* [j] vR
        C = np.tensordot(B.conj(), C, axes=([0, 1, 2], [1, 0, 2])) # [vL*] [j*] [vR*], [j] [vR*] [vR]
        return C


def init_FM_MPS(L, d=2, bc='finite'):

    B = np.zeros([1, d, 1], dtype=float)
    B[0, 0, 0] = 1.
    S = np.ones([1], dtype=float)
    Bs = [B.copy() for i in range(L)]
    Ss = [S.copy() for i in range(L)]
    return SimpleMPS(Bs, Ss, bc=bc)


def init_Neel_MPS(L, d=2, bc='finite'):

    S = np.ones([1], dtype=float)
    Bs = []
    for i in range(L):
        B = np.zeros([1, d, 1], dtype=float)
        if i % 2 == 0:
            B[0, 0, 0] = 1.
        else:
            B[0, -1, 0] = 1.
        Bs.append(B)
    Ss = [S.copy() for i in range(L)]
    return SimpleMPS(Bs, Ss, bc=bc)


def split_truncate_theta(theta, chi_max, eps):

    chivL, dL, dR, chivR = theta.shape
    theta = np.reshape(theta, [chivL * dL, dR * chivR])
    X, Y, Z = svd(theta, full_matrices=False)
    # truncate
    chivC = min(chi_max, np.sum(Y > eps))
    assert chivC >= 1
    piv = np.argsort(Y)[::-1][:chivC]  # keep the largest `chivC` singular values
    X, Y, Z = X[:, piv], Y[piv], Z[piv, :]
    # renormalize
    S = Y / np.linalg.norm(Y)  # == Y/sqrt(sum(Y**2))
    # split legs of X and Z
    A = np.reshape(X, [chivL, dL, chivC])
    B = np.reshape(Z, [chivC, dR, chivR])
    return A, S, B

class TLFIModel:
  def __init__(self,L,J,hs,hz,bc='finite'):
    assert bc in ['finite','infinite']
    self.L,self.d,self.bc = L,2,bc
    self.J= J
    self.hs = hs
    self.hz = hz
    self.sigmax = np.array([[0. ,1. ],[1. ,0. ]],)
    self.sigmay = np.array([[0. ,-1j],[1j , 0.]])
    self.sigmaz = np.array([[1. ,0. ],[0. ,-1. ]])
    self.id = np.eye(2) # define id as np.eye(2)
    self.init_H_bonds()
    self.init_H_MPO()
  def init_H_bonds(self):
    sx,sy,sz = self.sigmax,self.sigmay,self.sigmaz
    d = self.d
    nbonds = self.L -1 if self.bc == 'finite' else self.L
    H_list=[]
    for i in range(nbonds):
      hl=hr=0.5*self.hs
      hl1=hr1=0.5*self.hz
      if self.bc == 'finite':
        if i == 0:
          hl=self.hs
        if i+1 == self.L-1:
          hr=self.hs
      H_bond = -self.J * np.kron(sx,sx)
      # Use self.id instead of id
      H_bond = H_bond - hl*(-1)**i * np.kron(sz,self.id) + hr*(-1)**(i+1) * np.kron(self.id,sz) - hl1*(-1)**i * np.kron(sx,self.id) + hr1*(-1)**(i+1) * np.kron(self.id,sx)
      H_list.append(np.reshape(H_bond,[d,d,d,d]))
    self.H_bonds = H_list
  def init_H_MPO(self):
    w_list = []
    for i in range(self.L):
      w=np.zeros((3,3, self.d ,self.d),dtype = float)
      w[0,0]=w[2,2]=self.id
      w[0,1]= self.sigmaz
      w[0,2]= -self.hs*self.sigmaz-self.hz*self.sigmax
      w[1,2]= -self.J*self.sigmaz
      w_list.append(w)
    self.H_MPO = w_list

import numpy as np
from scipy.linalg import expm
# from .a_mps import split_truncate_theta


def calc_U_bonds(H_bonds, dt):

    d = H_bonds[0].shape[0]
    U_bonds = []
    for H in H_bonds:
        H = np.reshape(H, [d * d, d * d])
        U = expm(-dt * H)
        U_bonds.append(np.reshape(U, [d, d, d, d]))
    return U_bonds


def run_TEBD(psi, U_bonds, N_steps, chi_max, eps):

    Nbonds = psi.L - 1 if psi.bc == 'finite' else psi.L
    assert len(U_bonds) == Nbonds
    for n in range(N_steps):
        for k in [0, 1]:  # even, odd
            for i_bond in range(k, Nbonds, 2):
                update_bond(psi, i_bond, U_bonds[i_bond], chi_max, eps)
    # done


def update_bond(psi, i, U_bond, chi_max, eps):

    j = (i + 1) % psi.L
    # construct theta matrix
    theta = psi.get_theta2(i)  # vL i j vR
    # apply U
    Utheta = np.tensordot(U_bond, theta, axes=([2, 3], [1, 2]))  # i j [i*] [j*], vL [i] [j] vR
    Utheta = np.transpose(Utheta, [2, 0, 1, 3])  # vL i j vR
    # split and truncate
    Ai, Sj, Bj = split_truncate_theta(Utheta, chi_max, eps)
    # put back into MPS
    Gi = np.tensordot(np.diag(psi.Ss[i]**(-1)), Ai, axes=(1, 0))  # vL [vL*], [vL] i vC
    psi.Bs[i] = np.tensordot(Gi, np.diag(Sj), axes=(2, 0))  # vL i [vC], [vC] vC
    psi.Ss[j] = Sj  # vC
    psi.Bs[j] = Bj  # vC j vR


def example_TEBD_gs_tf_ising_finite(L, g, chi_max=30):
    print("finite TEBD, imaginary time evolution, transverse field Ising")
    print("L={L:d}, g={g:.2f}".format(L=L, g=g))
    # from . import a_mps
    # from . import b_model
    model =TLFIModel(L=L, J=1., hs=g,hz=0.5, bc='finite')
    psi = init_FM_MPS(model.L, model.d, model.bc)
    for dt in [0.1,0.01,0.001,1.e-5,1.e-6]:
        U_bonds = calc_U_bonds(model.H_bonds, dt)
        run_TEBD(psi, U_bonds, N_steps=500, chi_max=chi_max, eps=1.e-10)
        E = np.sum(psi.bond_expectation_value(model.H_bonds))
        print("dt = {dt:.5f}: E = {E:.13f}".format(dt=dt, E=E))
    print("final bond dimensions: ", psi.get_chi())
    mag_x = np.sum(psi.site_expectation_value(model.sigmax))
    mag_z = np.sum(psi.site_expectation_value(model.sigmaz))
    print("magnetization in X = {mag_x:.5f}".format(mag_x=mag_x))
    print("magnetization in Z = {mag_z:.5f}".format(mag_z=mag_z))
    print("entanglement entropy = ", psi.entanglement_entropy())
    # print("correlation length = ", psi.correlation_length())
    return E, psi.entanglement_entropy(), psi.get_chi()

a,b,c=example_TEBD_gs_tf_ising_finite(L=30, g=1.0)

import pylab as pl
b_reshaped=b.reshape(len(b),-1)
pl.pcolor(b_reshaped,cmap="jet")
pl.show()

import numpy as np

import numpy as np

site_ar = [10,15,20,25,28,32,36,38,42,45,40]
# Initialize a_n as a list of empty arrays, each with shape (20, 1)
a_n = [np.empty((8, 1)) for _ in range(len(site_ar))]

for i in range(len(site_ar)):
    e, b, c = example_TEBD_gs_tf_ising_finite(L=site_ar[i], g=1.0)
    # Assume b is the array with 20 values that needs to be stored
    a_n[i][:, 0] = b[:8]  # Storing the first 20 values of b into the ith array in a_n

# Converting list of arrays into a single numpy array under a single column
a_n_combined = np.concatenate(a_n, axis=0)

a_sep=[np.empty((8, len(site_ar))) for _ in range(len(site_ar))]
for i in range(len(site_ar)):
  for j in range(8,8,len(a_n)):
    a_sep[i][:,j]=a_n_combined[j]

for i in range(len(a_sep)):
  a_sep[i]=a_sep[i].flatten()

for i in range(len(a_sep)):
  print(a_sep[i])

for i in range(len(site_ar)):
  for j in range(8,8,len(a_n_combined)):
    print(i,j)

import matplotlib.pyplot as plt
import numpy as np
data = np.reshape(a_n,(1,-1))
plt.imshow(data,cmap='viridis',aspect='auto')
plt.colorbar()
plt.show()

plt.plot(site_ar,a_n,marker='o',linestyle='-',color='cyan')
plt.xlabel('site length')
plt.ylabel('Energy')
plt.grid()
plt.show()

b_reshaped=a_sep[1].reshape(len(a_sep[1]),-1)
pl.pcolor(b_reshaped,cmap="copper")
pl.show()
